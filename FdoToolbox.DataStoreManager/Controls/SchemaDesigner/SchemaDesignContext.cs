#region LGPL Header
// Copyright (C) 2010, Jackie Ng
// http://code.google.com/p/fdotoolbox, jumpinjackie@gmail.com
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
// 
//
// See license.txt for more/additional licensing information
#endregion
using System;
using System.Collections.Generic;
using System.Text;
using OSGeo.FDO.Schema;
using OSGeo.FDO.Commands.Schema;
using FdoToolbox.Core.Feature;
using System.ComponentModel;

namespace FdoToolbox.DataStoreManager.Controls.SchemaDesigner
{
    public class SchemaDesignContext
    {
        private FeatureSchemaCollection _schemas;
        private PhysicalSchemaMappingCollection _mappings;
        private BindingList<SpatialContextInfo> _spatialContexts;

        public bool SchemasChanged
        {
            get
            {
                foreach (FeatureSchema sc in _schemas)
                {
                    if (sc.ElementState != SchemaElementState.SchemaElementState_Unchanged)
                        return true;
                }
                return false;
            }
        }

        public DataType[] SupportedDataTypes
        {
            get
            {
                if (IsConnected)
                    return (DataType[])Connection.Capability.GetObjectCapability(CapabilityType.FdoCapabilityType_DataTypes);
                else
                    return (DataType[])Enum.GetValues(typeof(DataType));
            }
        }

        public DataType[] SupportedAutogenratedDataTypes
        {
            get
            {
                if (IsConnected)
                    return (DataType[])Connection.Capability.GetObjectCapability(CapabilityType.FdoCapabilityType_SupportedAutoGeneratedTypes);
                else
                    return new DataType[] { DataType.DataType_Int32, DataType.DataType_Int64 };
            }
        }

        public bool MappingsChanged
        {
            get;
            private set;
        }

        public bool IsConnected
        {
            get { return this.Connection != null; }
        }

        public SchemaDesignContext(FdoConnection conn)
        {
            _spatialContexts = new BindingList<SpatialContextInfo>();

            //Default disconnected state
            this.CanOverrideSchemas = false;
            this.CanShowPhysicalMapping = false;
            this.CanModifyExistingSchemas = false;
            this.CanHaveMultipleSpatialContexts = true;
            this.CanHaveMultipleSchemas = true;
            this.CanDestroySpatialContexts = false;


            if (conn == null)
            {
                _schemas = new FeatureSchemaCollection(null);
                _mappings = new PhysicalSchemaMappingCollection();
            }
            else
            {
                this.CanModifyExistingSchemas = conn.Capability.GetBooleanCapability(CapabilityType.FdoCapabilityType_SupportsSchemaModification);
                //this.CanOverrideSchemas = conn.Capability.GetBooleanCapability(CapabilityType.FdoCapabilityType_SupportsSchemaOverrides);
                //this.CanShowPhysicalMapping = Array.IndexOf(conn.Capability.GetArrayCapability(CapabilityType.FdoCapabilityType_CommandList), OSGeo.FDO.Commands.CommandType.CommandType_DescribeSchemaMapping) >= 0;
                this.CanHaveMultipleSchemas = conn.Capability.GetBooleanCapability(CapabilityType.FdoCapabilityType_SupportsMultipleSchemas);
                this.CanHaveMultipleSpatialContexts = conn.Capability.GetBooleanCapability(CapabilityType.FdoCapabilityType_SupportsMultipleSpatialContexts);
                this.CanDestroySpatialContexts = Array.IndexOf(conn.Capability.GetArrayCapability(CapabilityType.FdoCapabilityType_CommandList), OSGeo.FDO.Commands.CommandType.CommandType_DestroySpatialContext) >= 0;

                using (var svc = conn.CreateFeatureService())
                {
                    _schemas = svc.DescribeSchema();
                    _mappings = svc.DescribeSchemaMapping(true);
                    if (_mappings == null)
                        _mappings = new PhysicalSchemaMappingCollection();

                    var spatialContexts = svc.GetSpatialContexts();
                    foreach (var sc in spatialContexts)
                    {
                        _spatialContexts.Add(sc);
                    }
                }
            }

            this.Connection = conn;
        }

        /// <summary>
        /// Indicates if schema mappings can be shown (the connection was able
        /// to retrieve a default schema mapping collection). Schema element
        /// mapping UIs will be read-only
        /// </summary>
        public bool CanShowPhysicalMapping
        {
            get;
            private set;
        }

        public bool CanDestroySpatialContexts
        {
            get;
            private set;
        }

        public bool CanModifyExistingSchemas
        {
            get;
            private set;
        }

        /// <summary>
        /// Indicates if the current physical schema mapping can be modified. If supported, Schema element
        /// mapping UIs will be enabled
        /// </summary>
        public bool CanOverrideSchemas
        {
            get;
            private set;
        }

        public bool CanHaveMultipleSchemas
        {
            get;
            private set;
        }

        public bool CanHaveMultipleSpatialContexts
        {
            get;
            private set;
        }

        public FdoConnection Connection
        {
            get;
            private set;
        }

        public FeatureSchemaCollection Schemas
        {
            get { return _schemas; }
        }

        public PhysicalSchemaMappingCollection Mappings
        {
            get { return _mappings; }
        }

        public BindingList<SpatialContextInfo> SpatialContexts
        {
            get { return _spatialContexts; }
        }

        public ClassDefinition[] GetClasses(string schemaName)
        {
            var fidx = _schemas.IndexOf(schemaName);
            if (fidx >= 0)
            {
                var list = new List<ClassDefinition>();
                foreach (ClassDefinition cls in _schemas[fidx].Classes)
                {
                    list.Add(cls);
                }
                return list.ToArray();
            }
            return new ClassDefinition[0];
        }

        public ClassDefinition[] GetClassesExceptFor(string schemaName, string className)
        {
            var fidx = _schemas.IndexOf(schemaName);
            if (fidx >= 0)
            {
                var list = new List<ClassDefinition>();
                foreach (ClassDefinition cls in _schemas[fidx].Classes)
                {
                    if (cls.Name != className)
                        list.Add(cls);
                }
                return list.ToArray();
            }
            return new ClassDefinition[0];
        }

        public ClassDefinition GetClassDefinition(string schemaName, string className)
        {
            var fidx = _schemas.IndexOf(schemaName);
            if (fidx >= 0)
            {
                var classes = _schemas[fidx].Classes;
                var cidx = classes.IndexOf(className);
                if (cidx >= 0)
                {
                    return classes[cidx];
                }
            }
            return null;
        }

        private int counter = 0;

        public string GetName(string prefix)
        {
            counter++;
            return prefix + counter;
        }

        internal void ResetCounter()
        {
            counter = 0;
        }

        internal void AddSchema(FeatureSchema schema)
        {
            _schemas.Add(schema);
            //Broadcast
        }

        internal void AddClass(string schema, FeatureClass cls)
        {
            var fidx = _schemas.IndexOf(schema);
            if (fidx >= 0)
            {
                _schemas[fidx].Classes.Add(cls);
                //Broadcast
            }
        }

        internal void AddProperty(string schema, string cls, PropertyDefinition prop)
        {
            var fidx = _schemas.IndexOf(schema);
            if (fidx >= 0)
            {
                var cidx = _schemas[fidx].Classes.IndexOf(cls);
                if (cidx >= 0)
                {
                    var cd = _schemas[fidx].Classes[cidx];
                    cd.Properties.Add(prop);
                    
                    //Broadcast
                }
            }
        }

        /*
        internal void MakeIdentity(string schema, string cls, DataPropertyDefinition prop)
        {
            var fidx = _schemas.IndexOf(schema);
            if (fidx >= 0)
            {
                var cidx = _schemas[fidx].Classes.IndexOf(cls);
                if (cidx >= 0)
                {
                    var cd = _schemas[fidx].Classes[cidx];
                    cd.IdentityProperties.Add(prop);

                    //Broadcast
                }
            }
        }*/

        internal bool FixIncompatibilities()
        {
            return false;
        }
    }
}
